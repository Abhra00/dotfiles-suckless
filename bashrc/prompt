#    ┏┓┳┓┏┓┳┳┓┏┓┏┳┓
#    ┃┃┣┫┃┃┃┃┃┃┃ ┃
#    ┣┛┛┗┗┛┛ ┗┣┛ ┻
#

# Color prompt
force_color_prompt=yes
color_prompt=yes

# Useful prompt functions
# Git branch function
parse_git_branch() {
  if git rev-parse --is-inside-work-tree &>/dev/null; then
    local branch
    branch=$(git symbolic-ref --short HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
    if [ -n "$branch" ]; then
      printf " %s" "$branch"
    fi
  fi
}

# Git dirty function
parse_git_dirty() {
  # Check if we're in a git repo first
  git rev-parse --is-inside-work-tree &>/dev/null || return

  local status branch_status
  status=$(git status --porcelain --branch 2>/dev/null) || return
  [[ -z "$status" ]] && return

  printf " ["

  # Parse porcelain status more efficiently
  local untracked=0 added=0 modified=0 deleted=0 renamed=0
  
  # Single pass through status lines
  while IFS= read -r line; do
    case "${line:0:2}" in
      "??") ((untracked++)) ;;
      "A "|"A M") ((added++)) ;;
      " M"|"M "|"MM"|"AM") ((modified++)) ;;
      " D"|"D ") ((deleted++)) ;;
      "R "|"R M") ((renamed++)) ;;
      "C ") ((added++)) ;; # Copied files
      "U"*|"A"*"U"*) ((modified++)) ;; # Unmerged files
    esac
  done <<< "$status"

  # Output status symbols
  ((untracked > 0)) && printf " ?%d" "$untracked"
  ((added > 0)) && printf " +%d" "$added"
  ((modified > 0)) && printf " *%d" "$modified"
  ((deleted > 0)) && printf " -%d" "$deleted"
  ((renamed > 0)) && printf " >%d" "$renamed"

  # Parse branch status from the first line (branch info)
  branch_status=$(head -n1 <<< "$status")
  
  # Branch ahead/behind counts
  if [[ "$branch_status" =~ ahead[[:space:]]+([0-9]+) ]]; then
    printf " ⇡+%s" "${BASH_REMATCH[1]}"
  fi
  if [[ "$branch_status" =~ behind[[:space:]]+([0-9]+) ]]; then
    printf " ⇣-%s" "${BASH_REMATCH[1]}"
  fi

  printf " ]"
}

# Prompt symbol
PS_SYMBOL=$' \ueefe '

# Save last exit code before PS1 expands
set_prompt_status() {
  LAST_EXIT=$?
}
PROMPT_COMMAND=set_prompt_status

# Function to get color code based on exit status
get_prompt_color() {
  if [ $LAST_EXIT -eq 0 ]; then
    printf "92"   # bright-green
  else
    printf "91"   # bright-red
  fi
}

# Final prompt
PS1="\[\e]0;\w\a\]\
\[\e[93m\]\$(parse_git_branch)\[\e[0m\]\
\[\e[95m\]\$(parse_git_dirty)\[\e[0m\]\n\
\[\e[94m\]\W\[\e[0m\]\[\e[\$(get_prompt_color)m\]$PS_SYMBOL\[\e[0m\]"
